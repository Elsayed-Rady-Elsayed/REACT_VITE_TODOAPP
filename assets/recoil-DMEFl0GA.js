import{a as j}from"./react-BWtM72Fx.js";import{r as Ar}from"./react-dom-BHIg8MhZ.js";var Yn={};function Nr(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Lr=Nr,I=Lr;function Cr(e){return!!e&&typeof e.then=="function"}var W=Cr;function Vr(e,t){if(e!=null)return e;throw I(t??"Got unexpected null or undefined")}var q=Vr;function M(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class yt{getValue(){throw I("BaseLoadable")}toPromise(){throw I("BaseLoadable")}valueMaybe(){throw I("BaseLoadable")}valueOrThrow(){throw I(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw I("BaseLoadable")}promiseOrThrow(){throw I(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw I("BaseLoadable")}errorOrThrow(){throw I(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw I("BaseLoadable")}}class $r extends yt{constructor(t){super(),M(this,"state","hasValue"),M(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return W(n)?Le(n):Pe(n)?n:nt(n)}catch(n){return W(n)?Le(n.next(()=>this.map(t))):gt(n)}}}class Mr extends yt{constructor(t){super(),M(this,"state","hasError"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class Xn extends yt{constructor(t){super(),M(this,"state","loading"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Le(this.contents.then(n=>{const o=t(n);if(Pe(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(W(n))return n.then(()=>this.map(t).contents);throw n}))}}function nt(e){return Object.freeze(new $r(e))}function gt(e){return Object.freeze(new Mr(e))}function Le(e){return Object.freeze(new Xn(e))}function Jn(){return Object.freeze(new Xn(new Promise(()=>{})))}function Ir(e){return e.every(t=>t.state==="hasValue")?nt(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?gt(q(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Le(Promise.all(e.map(t=>t.contents)))}function Qn(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>Pe(r)?r:W(r)?Le(r):nt(r)),o=Ir(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,s,l)=>({...a,[s]:r[l]}),{}))}function Pe(e){return e instanceof yt}const Ur={of:e=>W(e)?Le(e):Pe(e)?e:nt(e),error:e=>gt(e),loading:()=>Jn(),all:Qn,isLoadable:Pe};var Ve={loadableWithValue:nt,loadableWithError:gt,loadableWithPromise:Le,loadableLoading:Jn,loadableAll:Qn,isLoadable:Pe,RecoilLoadable:Ur},Dr=Ve.loadableWithValue,kr=Ve.loadableWithError,Br=Ve.loadableWithPromise,Pr=Ve.loadableLoading,Or=Ve.loadableAll,Fr=Ve.isLoadable,xr=Ve.RecoilLoadable,ot=Object.freeze({__proto__:null,loadableWithValue:Dr,loadableWithError:kr,loadableWithPromise:Br,loadableLoading:Pr,loadableAll:Or,isLoadable:Fr,RecoilLoadable:xr});const Xt={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function zr(e,t){var n,o;const r=(n=Yn[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw I(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function Wr(e,t){var n;const o=(n=Yn[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function Gr(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(zr("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{Xt.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),Wr("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{Xt.RECOIL_GKS_ENABLED.add(n)})}))}Gr();var We=Xt;function bt(e){return We.RECOIL_GKS_ENABLED.has(e)}bt.setPass=e=>{We.RECOIL_GKS_ENABLED.add(e)};bt.setFail=e=>{We.RECOIL_GKS_ENABLED.delete(e)};bt.clear=()=>{We.RECOIL_GKS_ENABLED.clear()};var z=bt;function Kr(e,t,{error:n}={}){return null}var Hr=Kr,sn=Hr,Wt,Gt,Kt;const qr=(Wt=j.createMutableSource)!==null&&Wt!==void 0?Wt:j.unstable_createMutableSource,eo=(Gt=j.useMutableSource)!==null&&Gt!==void 0?Gt:j.unstable_useMutableSource,to=(Kt=j.useSyncExternalStore)!==null&&Kt!==void 0?Kt:j.unstable_useSyncExternalStore;function jr(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=j.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;return((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null}function Zr(){return z("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:z("recoil_sync_external_store")&&to!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:z("recoil_mutable_source")&&eo!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?z("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:z("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}function Yr(){return!1}var rt={createMutableSource:qr,useMutableSource:eo,useSyncExternalStore:to,currentRendererSupportsUseSyncExternalStore:jr,reactMode:Zr,isFastRefreshEnabled:Yr};class cn{constructor(t){M(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class no extends cn{}class oo extends cn{}function Xr(e){return e instanceof no||e instanceof oo}var Tt={AbstractRecoilValue:cn,RecoilState:no,RecoilValueReadOnly:oo,isRecoilValue:Xr},Jr=Tt.AbstractRecoilValue,Qr=Tt.RecoilState,ea=Tt.RecoilValueReadOnly,ta=Tt.isRecoilValue,Oe=Object.freeze({__proto__:null,AbstractRecoilValue:Jr,RecoilState:Qr,RecoilValueReadOnly:ea,isRecoilValue:ta});function na(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var wt=na;class ro{}const oa=new ro,Ce=new Map,ln=new Map;function ra(e){return wt(e,t=>q(ln.get(t)))}function aa(e){if(Ce.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function sa(e){We.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&aa(e.key),Ce.set(e.key,e);const t=e.set==null?new Oe.RecoilValueReadOnly(e.key):new Oe.RecoilState(e.key);return ln.set(e.key,t),t}class ao extends Error{}function ia(e){const t=Ce.get(e);if(t==null)throw new ao(`Missing definition for RecoilValue: "${e}""`);return t}function ca(e){return Ce.get(e)}const _t=new Map;function la(e){var t;if(!z("recoil_memory_managament_2020"))return;const n=Ce.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ce.delete(e),(o=so(e))===null||o===void 0||o(),_t.delete(e)}}function ua(e,t){z("recoil_memory_managament_2020")&&(t===void 0?_t.delete(e):_t.set(e,t))}function so(e){return _t.get(e)}var ie={nodes:Ce,recoilValues:ln,registerNode:sa,getNode:ia,getNodeMaybe:ca,deleteNodeConfigIfPossible:la,setConfigDeletionHandler:ua,getConfigDeletionHandler:so,recoilValuesForKeys:ra,NodeMissingError:ao,DefaultValue:ro,DEFAULT_VALUE:oa};function da(e,t){t()}var fa={enqueueExecution:da};function ha(e,t){return t={exports:{}},e(t,t.exports),t.exports}var va=ha(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,s=r/2,l=r/4,u={},f=function(i){return function(){return i}},v=n.hash=function(c){var i=typeof c>"u"?"undefined":t(c);if(i==="number")return c;i!=="string"&&(c+="");for(var h=0,m=0,R=c.length;m<R;++m){var g=c.charCodeAt(m);h=(h<<5)-h+g|0}return h},_=function(i){return i-=i>>1&1431655765,i=(i&858993459)+(i>>2&858993459),i=i+(i>>4)&252645135,i+=i>>8,i+=i>>16,i&127},V=function(i,h){return h>>>i&a},C=function(i){return 1<<i},y=function(i,h){return _(i&h-1)},E=function(i,h,m,R){var g=R;if(!i){var L=R.length;g=new Array(L);for(var A=0;A<L;++A)g[A]=R[A]}return g[h]=m,g},Z=function(i,h,m){var R=m.length-1,g=0,L=0,A=m;if(i)g=L=h;else for(A=new Array(R);g<h;)A[L++]=m[g++];for(++g;g<=R;)A[L++]=m[g++];return i&&(A.length=R),A},ne=function(i,h,m,R){var g=R.length;if(i){for(var L=g;L>=h;)R[L--]=R[L];return R[h]=m,R}for(var A=0,N=0,U=new Array(g+1);A<h;)U[N++]=R[A++];for(U[h]=m;A<g;)U[++N]=R[A++];return U},w=1,B=2,J=3,x=4,G={__hamt_isEmpty:!0},Y=function(i){return i===G||i&&i.__hamt_isEmpty},re=function(i,h,m,R){return{type:w,edit:i,hash:h,key:m,value:R,_modify:Ie}},Re=function(i,h,m){return{type:B,edit:i,hash:h,children:m,_modify:Ue}},ee=function(i,h,m){return{type:J,edit:i,mask:h,children:m,_modify:P}},ue=function(i,h,m){return{type:x,edit:i,size:h,children:m,_modify:O}},Me=function(i){return i===G||i.type===w||i.type===B},Q=function(i,h,m,R,g){for(var L=[],A=R,N=0,U=0;A;++U)A&1&&(L[U]=g[N++]),A>>>=1;return L[h]=m,ue(i,N+1,L)},ce=function(i,h,m,R){for(var g=new Array(h-1),L=0,A=0,N=0,U=R.length;N<U;++N)if(N!==m){var H=R[N];H&&!Y(H)&&(g[L++]=H,A|=1<<N)}return ee(i,A,g)},Ee=function c(i,h,m,R,g,L){if(m===g)return Re(i,m,[L,R]);var A=V(h,m),N=V(h,g);return ee(i,C(A)|C(N),A===N?[c(i,h+o,m,R,g,L)]:A<N?[R,L]:[L,R])},de=function(i,h,m,R,g,L,A,N){for(var U=g.length,H=0;H<U;++H){var ae=g[H];if(m(A,ae.key)){var oe=ae.value,he=L(oe);return he===oe?g:he===u?(--N.value,Z(i,H,g)):E(i,H,re(h,R,A,he),g)}}var pe=L();return pe===u?g:(++N.value,E(i,U,re(h,R,A,pe),g))},ye=function(i,h){return i===h.edit},Ie=function(i,h,m,R,g,L,A){if(h(L,this.key)){var N=R(this.value);return N===this.value?this:N===u?(--A.value,G):ye(i,this)?(this.value=N,this):re(i,g,L,N)}var U=R();return U===u?this:(++A.value,Ee(i,m,this.hash,this,g,re(i,g,L,U)))},Ue=function(i,h,m,R,g,L,A){if(g===this.hash){var N=ye(i,this),U=de(N,i,h,this.hash,this.children,R,L,A);return U===this.children?this:U.length>1?Re(i,this.hash,U):U[0]}var H=R();return H===u?this:(++A.value,Ee(i,m,this.hash,this,g,re(i,g,L,H)))},P=function(i,h,m,R,g,L,A){var N=this.mask,U=this.children,H=V(m,g),ae=C(H),oe=y(N,ae),he=N&ae,pe=he?U[oe]:G,De=pe._modify(i,h,m+o,R,g,L,A);if(pe===De)return this;var lt=ye(i,this),Ke=N,He=void 0;if(he&&Y(De)){if(Ke&=~ae,!Ke)return G;if(U.length<=2&&Me(U[oe^1]))return U[oe^1];He=Z(lt,oe,U)}else if(!he&&!Y(De)){if(U.length>=s)return Q(i,H,De,N,U);Ke|=ae,He=ne(lt,oe,De,U)}else He=E(lt,oe,De,U);return lt?(this.mask=Ke,this.children=He,this):ee(i,Ke,He)},O=function(i,h,m,R,g,L,A){var N=this.size,U=this.children,H=V(m,g),ae=U[H],oe=(ae||G)._modify(i,h,m+o,R,g,L,A);if(ae===oe)return this;var he=ye(i,this),pe=void 0;if(Y(ae)&&!Y(oe))++N,pe=E(he,H,oe,U);else if(!Y(ae)&&Y(oe)){if(--N,N<=l)return ce(i,N,H,U);pe=E(he,H,G,U)}else pe=E(he,H,oe,U);return he?(this.size=N,this.children=pe,this):ue(i,N,pe)};G._modify=function(c,i,h,m,R,g,L){var A=m();return A===u?G:(++L.value,re(c,R,g,A))};function d(c,i,h,m,R){this._editable=c,this._edit=i,this._config=h,this._root=m,this._size=R}d.prototype.setTree=function(c,i){return this._editable?(this._root=c,this._size=i,this):c===this._root?this:new d(this._editable,this._edit,this._config,c,i)};var p=n.tryGetHash=function(c,i,h,m){for(var R=m._root,g=0,L=m._config.keyEq;;)switch(R.type){case w:return L(h,R.key)?R.value:c;case B:{if(i===R.hash)for(var A=R.children,N=0,U=A.length;N<U;++N){var H=A[N];if(L(h,H.key))return H.value}return c}case J:{var ae=V(g,i),oe=C(ae);if(R.mask&oe){R=R.children[y(R.mask,oe)],g+=o;break}return c}case x:{if(R=R.children[V(g,i)],R){g+=o;break}return c}default:return c}};d.prototype.tryGetHash=function(c,i,h){return p(c,i,h,this)};var S=n.tryGet=function(c,i,h){return p(c,h._config.hash(i),i,h)};d.prototype.tryGet=function(c,i){return S(c,i,this)};var $=n.getHash=function(c,i,h){return p(void 0,c,i,h)};d.prototype.getHash=function(c,i){return $(c,i,this)},n.get=function(c,i){return p(void 0,i._config.hash(c),c,i)},d.prototype.get=function(c,i){return S(i,c,this)};var b=n.has=function(c,i,h){return p(u,c,i,h)!==u};d.prototype.hasHash=function(c,i){return b(c,i,this)};var k=n.has=function(c,i){return b(i._config.hash(c),c,i)};d.prototype.has=function(c){return k(c,this)};var D=function(i,h){return i===h};n.make=function(c){return new d(0,0,{keyEq:c&&c.keyEq||D,hash:c&&c.hash||v},G,0)},n.empty=n.make();var T=n.isEmpty=function(c){return c&&!!Y(c._root)};d.prototype.isEmpty=function(){return T(this)};var K=n.modifyHash=function(c,i,h,m){var R={value:m._size},g=m._root._modify(m._editable?m._edit:NaN,m._config.keyEq,0,c,i,h,R);return m.setTree(g,R.value)};d.prototype.modifyHash=function(c,i,h){return K(h,c,i,this)};var te=n.modify=function(c,i,h){return K(c,h._config.hash(i),i,h)};d.prototype.modify=function(c,i){return te(i,c,this)};var F=n.setHash=function(c,i,h,m){return K(f(h),c,i,m)};d.prototype.setHash=function(c,i,h){return F(c,i,h,this)};var X=n.set=function(c,i,h){return F(h._config.hash(c),c,i,h)};d.prototype.set=function(c,i){return X(c,i,this)};var ve=f(u),Ae=n.removeHash=function(c,i,h){return K(ve,c,i,h)};d.prototype.removeHash=d.prototype.deleteHash=function(c,i){return Ae(c,i,this)};var fe=n.remove=function(c,i){return Ae(i._config.hash(c),c,i)};d.prototype.remove=d.prototype.delete=function(c){return fe(c,this)};var le=n.beginMutation=function(c){return new d(c._editable+1,c._edit+1,c._config,c._root,c._size)};d.prototype.beginMutation=function(){return le(this)};var wn=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};d.prototype.endMutation=function(){return wn(this)};var _r=n.mutate=function(c,i){var h=le(i);return c(h),wn(h)};d.prototype.mutate=function(c){return _r(c,this)};var Ft=function(i){return i&&En(i[0],i[1],i[2],i[3],i[4])},En=function(i,h,m,R,g){for(;m<i;){var L=h[m++];if(L&&!Y(L))return An(L,R,[i,h,m,R,g])}return Ft(g)},An=function(i,h,m){switch(i.type){case w:return{value:h(i),rest:m};case B:case x:case J:var R=i.children;return En(R.length,R,0,h,m);default:return Ft(m)}},Sr={done:!0};function xt(c){this.v=c}xt.prototype.next=function(){if(!this.v)return Sr;var c=this.v;return this.v=Ft(c.rest),c},xt.prototype[Symbol.iterator]=function(){return this};var zt=function(i,h){return new xt(An(i._root,h))},mr=function(i){return[i.key,i.value]},Rr=n.entries=function(c){return zt(c,mr)};d.prototype.entries=d.prototype[Symbol.iterator]=function(){return Rr(this)};var yr=function(i){return i.key},gr=n.keys=function(c){return zt(c,yr)};d.prototype.keys=function(){return gr(this)};var br=function(i){return i.value},Tr=n.values=d.prototype.values=function(c){return zt(c,br)};d.prototype.values=function(){return Tr(this)};var Nn=n.fold=function(c,i,h){var m=h._root;if(m.type===w)return c(i,m.value,m.key);for(var R=[m.children],g=void 0;g=R.pop();)for(var L=0,A=g.length;L<A;){var N=g[L++];N&&N.type&&(N.type===w?i=c(i,N.value,N.key):R.push(N.children))}return i};d.prototype.fold=function(c,i){return Nn(c,i,this)};var wr=n.forEach=function(c,i){return Nn(function(h,m,R){return c(m,R,i)},null,i)};d.prototype.forEach=function(c){return wr(c,this)};var Er=n.count=function(c){return c._size};d.prototype.count=function(){return Er(this)},Object.defineProperty(d.prototype,"size",{get:d.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class pa{constructor(t){M(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return dn(this)}toMap(){return new Map(this._map)}}class un{constructor(t){if(M(this,"_hamt",va.empty.beginMutation()),t instanceof un){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return dn(this)}toMap(){return new Map(this._hamt)}}function dn(e){return z("recoil_hamt_2020")?new un(e):new pa(e)}var _a={persistentMap:dn},Sa=_a.persistentMap,ma=Object.freeze({__proto__:null,persistentMap:Sa});function Ra(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var Qe=Ra;function ya(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var St=ya;function ga(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function ba(e){return{nodeDeps:St(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:St(e.nodeToNodeSubscriptions,t=>new Set(t))}}function Ht(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,s=r.get(e);if(s&&o&&s!==o.nodeDeps.get(e))return;r.set(e,t);const l=s==null?t:Qe(t,s);for(const u of l)a.has(u)||a.set(u,new Set),q(a.get(u)).add(e);if(s){const u=Qe(s,t);for(const f of u){if(!a.has(f))return;const v=q(a.get(f));v.delete(e),v.size===0&&a.delete(f)}}}function Ta(e,t,n,o){var r,a,s,l;const u=n.getState();o===u.currentTree.version||o===((r=u.nextTree)===null||r===void 0?void 0:r.version)||((a=u.previousTree)===null||a===void 0||a.version);const f=n.getGraph(o);if(Ht(e,t,f),o===((s=u.previousTree)===null||s===void 0?void 0:s.version)){const _=n.getGraph(u.currentTree.version);Ht(e,t,_,f)}if(o===((l=u.previousTree)===null||l===void 0?void 0:l.version)||o===u.currentTree.version){var v;const _=(v=u.nextTree)===null||v===void 0?void 0:v.version;if(_!==void 0){const V=n.getGraph(_);Ht(e,t,V,f)}}}var at={cloneGraph:ba,graph:ga,saveDepsToStore:Ta};let wa=0;const Ea=()=>wa++;let Aa=0;const Na=()=>Aa++;let La=0;const Ca=()=>La++;var Et={getNextTreeStateVersion:Ea,getNextStoreID:Na,getNextComponentID:Ca};const{persistentMap:Ln}=ma,{graph:Va}=at,{getNextTreeStateVersion:io}=Et;function co(){const e=io();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Ln(),nonvalidatedAtoms:Ln()}}function $a(){const e=co();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,Va()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var lo={makeEmptyTreeState:co,makeEmptyStoreState:$a,getNextTreeStateVersion:io};class uo{}function Ma(){return new uo}var At={RetentionZone:uo,retentionZone:Ma};function Ia(e,t){const n=new Set(e);return n.add(t),n}function Ua(e,t){const n=new Set(e);return n.delete(t),n}function Da(e,t,n){const o=new Map(e);return o.set(t,n),o}function ka(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o}function Ba(e,t){const n=new Map(e);return n.delete(t),n}function Pa(e,t){const n=new Map(e);return t.forEach(o=>n.delete(o)),n}var fo={setByAddingToSet:Ia,setByDeletingFromSet:Ua,mapBySettingInMap:Da,mapByUpdatingInMap:ka,mapByDeletingFromMap:Ba,mapByDeletingMultipleFromMap:Pa};function*Oa(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var fn=Oa;function Fa(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var ho=Fa;const{getNode:st,getNodeMaybe:xa,recoilValuesForKeys:Cn}=ie,{RetentionZone:Vn}=At,{setByAddingToSet:za}=fo,Wa=Object.freeze(new Set);class Ga extends Error{}function Ka(e,t,n){if(!z("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let s=o.get(a);s||o.set(a,s=new Set),s.add(t)}if(n instanceof Vn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!z("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function s(l){const u=a.nodesRetainedByZone.get(l);u==null||u.delete(t),u&&u.size===0&&a.nodesRetainedByZone.delete(l)}if(n instanceof Vn)s(n);else if(Array.isArray(n))for(const l of n)s(l)}}function hn(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=st(n),s=Ka(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),s()})}function Ha(e,t,n){hn(e,e.getState().currentTree,t,n)}function qa(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function ja(e,t,n){return hn(e,t,n,"get"),st(n).get(e,t)}function vo(e,t,n){return st(n).peek(e,t)}function Za(e,t,n){var o;const r=xa(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:za(e.dirtyAtoms,t)}}function Ya(e,t,n,o){const r=st(n);if(r.set==null)throw new Ga(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return hn(e,t,n,"set"),a(e,t,o)}function Xa(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=st(n).nodeType;return ho({type:a},{loadable:()=>vo(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var s;return Cn((s=r.nodeDeps.get(n))!==null&&s!==void 0?s:[])},subscribers:()=>{var s,l;return{nodes:Cn(fn(po(e,t,new Set([n])),u=>u!==n)),components:wt((s=(l=o.nodeToComponentSubscriptions.get(n))===null||l===void 0?void 0:l.values())!==null&&s!==void 0?s:[],([u])=>({name:u}))}}})}function po(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var s;o.add(l);const u=(s=a.nodeToNodeSubscriptions.get(l))!==null&&s!==void 0?s:Wa;for(const f of u)o.has(f)||r.push(f)}return o}var Te={getNodeLoadable:ja,peekNodeLoadable:vo,setNodeValue:Ya,initializeNode:Ha,cleanUpNode:qa,setUnvalidatedAtomValue_DEPRECATED:Za,peekNodeInfo:Xa,getDownstreamNodes:po};let _o=null;function Ja(e){_o=e}function Qa(){var e;(e=_o)===null||e===void 0||e()}var So={setInvalidateMemoizedSnapshot:Ja,invalidateMemoizedSnapshot:Qa};const{getDownstreamNodes:es,getNodeLoadable:mo,setNodeValue:ts}=Te,{getNextComponentID:ns}=Et,{getNode:os,getNodeMaybe:Ro}=ie,{DefaultValue:vn}=ie,{reactMode:rs}=rt,{AbstractRecoilValue:as,RecoilState:ss,RecoilValueReadOnly:is,isRecoilValue:cs}=Oe,{invalidateMemoizedSnapshot:ls}=So;function us(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||(n.version,(r=a.previousTree)===null||r===void 0||r.version);const s=mo(e,n,t);return s.state==="loading"&&s.contents.catch(()=>{}),s}function ds(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof vn?n.delete(r):n.set(r,o)}),n}function fs(e,t,{key:n},o){if(typeof o=="function"){const r=mo(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw I(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function hs(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,s=fs(e,t,r,a),l=ts(e,t,r.key,s);for(const[u,f]of l.entries())Jt(t,u,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;Jt(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,s=Ro(r);s==null||(o=s.invalidate)===null||o===void 0||o.call(s,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else sn(`Unknown action ${n.type}`)}function Jt(e,t,n){n.state==="hasValue"&&n.contents instanceof vn?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function yo(e,t){e.replaceState(n=>{const o=go(n);for(const r of t)hs(e,o,r);return bo(e,o),ls(),o})}function Nt(e,t){if(et.length){const n=et[et.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else yo(e,[t])}const et=[];function vs(){const e=new Map;return et.push(e),()=>{for(const[t,n]of e)yo(t,n);et.pop()}}function go(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function bo(e,t){const n=es(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=Ro(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function To(e,t,n){Nt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function ps(e,t,n){if(n instanceof vn)return To(e,t,n);Nt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function _s(e,t){Nt(e,{type:"markModified",recoilValue:t})}function Ss(e,t,n){Nt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function ms(e,{key:t},n,o=null){const r=ns(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),q(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const s=rs();if(s.early&&(s.mode==="LEGACY"||s.mode==="MUTABLE_SOURCE")){const l=e.getState().nextTree;l&&l.dirtyAtoms.has(t)&&n(l)}return{release:()=>{const l=e.getState(),u=l.nodeToComponentSubscriptions.get(t);u===void 0||!u.has(r)||(u.delete(r),u.size===0&&l.nodeToComponentSubscriptions.delete(t))}}}function Rs(e,t){var n;const{currentTree:o}=e.getState(),r=os(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var Se={RecoilValueReadOnly:is,AbstractRecoilValue:as,RecoilState:ss,getRecoilValueAsLoadable:us,setRecoilValue:To,setRecoilValueLoadable:ps,markRecoilValueModified:_s,setUnvalidatedRecoilValue:Ss,subscribeToRecoilValue:ms,isRecoilValue:cs,applyAtomValueWrites:ds,batchStart:vs,writeLoadableToTreeState:Jt,invalidateDownstreams:bo,copyTreeState:go,refreshRecoilValue:Rs};function ys(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var gs=ys;const{cleanUpNode:bs}=Te,{deleteNodeConfigIfPossible:Ts,getNode:wo}=ie,{RetentionZone:Eo}=At,ws=12e4,Ao=new Set;function No(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return;const r=new Set;for(const s of t)if(s instanceof Eo)for(const l of Ls(n,s))r.add(l);else r.add(s);const a=Es(e,r);for(const s of a)Ns(e,o,s)}function Es(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return l(t),a;function l(u){const f=new Set,v=As(e,o,u,a,s);for(const y of v){var _;if(wo(y).retainedBy==="recoilRoot"){s.add(y);continue}if(((_=n.retention.referenceCounts.get(y))!==null&&_!==void 0?_:0)>0){s.add(y);continue}if(Lo(y).some(Z=>n.retention.referenceCounts.get(Z))){s.add(y);continue}const E=r.nodeToNodeSubscriptions.get(y);if(E&&gs(E,Z=>s.has(Z))){s.add(y);continue}a.add(y),f.add(y)}const V=new Set;for(const y of f)for(const E of(C=r.nodeDeps.get(y))!==null&&C!==void 0?C:Ao){var C;a.has(E)||V.add(E)}V.size&&l(V)}}function As(e,t,n,o,r){const a=e.getGraph(t.version),s=[],l=new Set;for(;n.size>0;)u(q(n.values().next().value));return s;function u(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(l.has(f))return;const v=a.nodeToNodeSubscriptions.get(f);if(v)for(const _ of v)u(_);l.add(f),n.delete(f),s.push(f)}}function Ns(e,t,n){if(!z("recoil_memory_managament_2020"))return;bs(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=Lo(n);for(const u of r){var a;(a=o.retention.nodesRetainedByZone.get(u))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const u=s.nodeDeps.get(n);if(u!==void 0){s.nodeDeps.delete(n);for(const f of u){var l;(l=s.nodeToNodeSubscriptions.get(f))===null||l===void 0||l.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}Ts(n)}function Ls(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:Ao}function Lo(e){const t=wo(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof Eo?[t]:t}function Cs(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):No(e,new Set([t]))}function Vs(e,t,n){var o;if(!z("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Co(e,t):r.set(t,a)}function Co(e,t){if(!z("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),Cs(e,t)}function $s(e){if(!z("recoil_memory_managament_2020"))return;const t=e.getState();No(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Ms(e){return e===void 0?"recoilRoot":e}var $e={SUSPENSE_TIMEOUT_MS:ws,updateRetainCount:Vs,updateRetainCountToZero:Co,releaseScheduledRetainablesNow:$s,retainedByOptionWithDefault:Ms};const{unstable_batchedUpdates:Is}=Ar;var Us={unstable_batchedUpdates:Is};const{unstable_batchedUpdates:Ds}=Us;var ks={unstable_batchedUpdates:Ds};const{batchStart:Bs}=Se,{unstable_batchedUpdates:Ps}=ks;let pn=Ps||(e=>e());const Os=e=>{pn=e},Fs=()=>pn,xs=e=>{pn(()=>{let t=()=>{};try{t=Bs(),e()}finally{t()}})};var Lt={getBatcher:Fs,setBatcher:Os,batchUpdates:xs};function*zs(e){for(const t of e)for(const n of t)yield n}var Vo=zs;const $o=typeof Window>"u"||typeof window>"u",Ws=e=>!$o&&(e===window||e instanceof Window),Gs=typeof navigator<"u"&&navigator.product==="ReactNative";var Ct={isSSR:$o,isReactNative:Gs,isWindow:Ws};function Ks(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e(...o)),n[r]}}function Hs(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e(...r)),o}}function qs(e,t){let n,o;return[(...s)=>{const l=t(...s);return n===l||(n=l,o=e(...s)),o},()=>{n=null}]}var js={memoizeWithArgsHash:Ks,memoizeOneWithArgsHash:Hs,memoizeOneWithArgsHashAndInvalidation:qs};const{batchUpdates:Qt}=Lt,{initializeNode:Zs,peekNodeInfo:Ys}=Te,{graph:Xs}=at,{getNextStoreID:Js}=Et,{DEFAULT_VALUE:Qs,recoilValues:$n,recoilValuesForKeys:Mn}=ie,{AbstractRecoilValue:ei,getRecoilValueAsLoadable:ti,setRecoilValue:In,setUnvalidatedRecoilValue:ni}=Se,{updateRetainCount:pt}=$e,{setInvalidateMemoizedSnapshot:oi}=So,{getNextTreeStateVersion:ri,makeEmptyStoreState:ai}=lo,{isSSR:si}=Ct,{memoizeOneWithArgsHashAndInvalidation:ii}=js;class Vt{constructor(t,n){M(this,"_store",void 0),M(this,"_refCount",1),M(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),ti(this._store,o))),M(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),M(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];const s=this._store.getState().currentTree;return Mn(s.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?$n.values():o.isInitialized===!0?Mn(Vo([r,a])):fn($n.values(),({key:s})=>!r.has(s)&&!a.has(s))}),M(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),Ys(this._store,this._store.getState().currentTree,o))),M(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new en(this,Qt);return o(r),r}),M(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new en(this,Qt);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:Js(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return q(r.get(o));const a=Xs();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw I("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)Zs(this._store,o,"get"),pt(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0,this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){si||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!z("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){z("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function Mo(e,t,n=!1){const o=e.getState(),r=n?ri():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(wt(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function ci(e){const t=new Vt(ai());return e!=null?t.map(e):t}const[Un,Io]=ii((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:q(o.previousTree);return new Vt(Mo(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});oi(Io);function li(e,t="latest"){const n=Un(e,t);return n.isRetained()?n:(Io(),Un(e,t))}class en extends Vt{constructor(t,n){super(Mo(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),M(this,"_batch",void 0),M(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{pt(a,o.key,1),In(this.getStore_INTERNAL(),o,r)})}),M(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{pt(r,o.key,1),In(this.getStore_INTERNAL(),o,Qs)})}),M(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();Qt(()=>{for(const[a,s]of o.entries())pt(r,a,1),ni(r,new ei(a),s)})}),this._batch=n}}var $t={Snapshot:Vt,MutableSnapshot:en,freshSnapshot:ci,cloneSnapshot:li},ui=$t.Snapshot,di=$t.MutableSnapshot,fi=$t.freshSnapshot,hi=$t.cloneSnapshot,Mt=Object.freeze({__proto__:null,Snapshot:ui,MutableSnapshot:di,freshSnapshot:fi,cloneSnapshot:hi});function vi(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var pi=vi;const{useRef:_i}=j;function Si(e){const t=_i(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var Dn=Si;const{getNextTreeStateVersion:mi,makeEmptyStoreState:Uo}=lo,{cleanUpNode:Ri,getDownstreamNodes:yi,initializeNode:gi,setNodeValue:bi,setUnvalidatedAtomValue_DEPRECATED:Ti}=Te,{graph:wi}=at,{cloneGraph:Ei}=at,{getNextStoreID:Do}=Et,{createMutableSource:qt,reactMode:ko}=rt,{applyAtomValueWrites:Ai}=Se,{releaseScheduledRetainablesNow:Bo}=$e,{freshSnapshot:Ni}=Mt,{useCallback:Li,useContext:Po,useEffect:tn,useMemo:Ci,useRef:Vi,useState:$i}=j;function qe(){throw I("This component must be used inside a <RecoilRoot> component.")}const Oo=Object.freeze({storeID:Do(),getState:qe,replaceState:qe,getGraph:qe,subscribeToTransactions:qe,addTransactionMetadata:qe});let nn=!1;function kn(e){if(nn)throw I("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){z("recoil_memory_managament_2020")&&z("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Bo(e);const n=t.currentTree.version,o=mi();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Ei(q(t.graphsByVersion.get(n))))}}const Fo=j.createContext({current:Oo}),It=()=>Po(Fo),xo=j.createContext(null);function Mi(){return Po(xo)}function _n(e,t,n){const o=yi(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[s,[l,u]]of a)u(n)}}function zo(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[s,l]of a)l(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!ko().early||t.suspendedComponentResolvers.size>0)&&(_n(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Ii(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,zo(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):sn("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,z("recoil_memory_managament_2020")&&n==null&&Bo(e)}finally{t.commitDepth--}}function Ui({setNotifyBatcherOfChange:e}){const t=It(),[,n]=$i([]);return e(()=>n({})),tn(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),tn(()=>{fa.enqueueExecution("Batcher",()=>{Ii(t.current)})}),null}function Di(e,t){const n=Uo();return t({set:(o,r)=>{const a=n.currentTree,s=bi(e,a,o.key,r),l=new Set(s.keys()),u=a.nonvalidatedAtoms.clone();for(const f of l)u.delete(f);n.currentTree={...a,dirtyAtoms:pi(a.dirtyAtoms,l),atomValues:Ai(a.atomValues,s),nonvalidatedAtoms:u}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Ti(n.currentTree,a,r)})}}),n}function ki(e){const t=Ni(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let Bn=0;function Bi({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=C=>{const y=r.current.graphsByVersion;if(y.has(C))return q(y.get(C));const E=wi();return y.set(C,E),E},s=(C,y)=>{if(y==null){const{transactionSubscriptions:E}=_.current.getState(),Z=Bn++;return E.set(Z,C),{release:()=>{E.delete(Z)}}}else{const{nodeTransactionSubscriptions:E}=_.current.getState();E.has(y)||E.set(y,new Map);const Z=Bn++;return q(E.get(y)).set(Z,C),{release:()=>{const ne=E.get(y);ne&&(ne.delete(Z),ne.size===0&&E.delete(y))}}}},l=C=>{kn(_.current);for(const y of Object.keys(C))q(_.current.getState().nextTree).transactionMetadata[y]=C[y]},u=C=>{kn(_.current);const y=q(r.current.nextTree);let E;try{nn=!0,E=C(y)}finally{nn=!1}E!==y&&(r.current.nextTree=E,ko().early&&_n(_.current,r.current,E),q(f.current)())},f=Vi(null),v=Li(C=>{f.current=C},[f]),_=Dn(()=>n??{storeID:Do(),getState:()=>r.current,replaceState:u,getGraph:a,subscribeToTransactions:s,addTransactionMetadata:l});n!=null&&(_.current=n),r=Dn(()=>e!=null?Di(_.current,e):t!=null?ki(t):Uo());const V=Ci(()=>qt==null?void 0:qt(r,()=>r.current.currentTree.version),[r]);return tn(()=>{const C=_.current;for(const y of new Set(C.getState().knownAtoms))gi(C,y,"get");return()=>{for(const y of C.getState().knownAtoms)Ri(C,y)}},[_]),j.createElement(Fo.Provider,{value:_},j.createElement(xo.Provider,{value:V},j.createElement(Ui,{setNotifyBatcherOfChange:v}),o))}function Pi(e){const{override:t,...n}=e,o=It();return t===!1&&o.current!==Oo?e.children:j.createElement(Bi,n)}function Oi(){return It().current.storeID}var ge={RecoilRoot:Pi,useStoreRef:It,useRecoilMutableSource:Mi,useRecoilStoreID:Oi,notifyComponents_FOR_TESTING:_n,sendEndOfBatchNotifications_FOR_TESTING:zo};function Fi(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var xi=Fi;const{useEffect:zi,useRef:Wi}=j;function Gi(e){const t=Wi();return zi(()=>{t.current=e}),t.current}var Wo=Gi;const{useStoreRef:Ki}=ge,{SUSPENSE_TIMEOUT_MS:Hi}=$e,{updateRetainCount:je}=$e,{RetentionZone:qi}=At,{useEffect:ji,useRef:Zi}=j,{isSSR:Pn}=Ct;function Yi(e){if(z("recoil_memory_managament_2020"))return Xi(e)}function Xi(e){const n=(Array.isArray(e)?e:[e]).map(s=>s instanceof qi?s:s.key),o=Ki();ji(()=>{if(!z("recoil_memory_managament_2020"))return;const s=o.current;if(r.current&&!Pn)window.clearTimeout(r.current),r.current=null;else for(const l of n)je(s,l,1);return()=>{for(const l of n)je(s,l,-1)}},[o,...n]);const r=Zi(),a=Wo(n);if(!Pn&&(a===void 0||!xi(a,n))){const s=o.current;for(const l of n)je(s,l,1);if(a)for(const l of a)je(s,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const l of n)je(s,l,-1)},Hi)}}var Sn=Yi;function Ji(){return"<component name not available>"}var it=Ji;const{batchUpdates:Qi}=Lt,{DEFAULT_VALUE:Go}=ie,{currentRendererSupportsUseSyncExternalStore:ec,reactMode:Ge,useMutableSource:tc,useSyncExternalStore:nc}=rt,{useRecoilMutableSource:oc,useStoreRef:me}=ge,{AbstractRecoilValue:on,getRecoilValueAsLoadable:ct,setRecoilValue:mt,setUnvalidatedRecoilValue:rc,subscribeToRecoilValue:Fe}=Se,{useCallback:se,useEffect:xe,useMemo:Ko,useRef:tt,useState:mn}=j,{setByAddingToSet:ac}=fo,{isSSR:sc}=Ct;function Rn(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),sc&&W(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:I(`Invalid value of loadable atom "${t.key}"`)}function ic(){const e=it(),t=me(),[,n]=mn([]),o=tt(new Set);o.current=new Set;const r=tt(new Set),a=tt(new Map),s=se(u=>{const f=a.current.get(u);f&&(f.release(),a.current.delete(u))},[a]),l=se((u,f)=>{a.current.has(f)&&n([])},[]);return xe(()=>{const u=t.current;Qe(o.current,r.current).forEach(f=>{if(a.current.has(f))return;const v=Fe(u,new on(f),V=>l(V,f),e);a.current.set(f,v),u.getState().nextTree?u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(u.getState(),f)}):l(u.getState(),f)}),Qe(r.current,o.current).forEach(f=>{s(f)}),r.current=o.current}),xe(()=>{const u=a.current;return Qe(o.current,new Set(u.keys())).forEach(f=>{const v=Fe(t.current,new on(f),_=>l(_,f),e);u.set(f,v)}),()=>u.forEach((f,v)=>s(v))},[e,t,s,l]),Ko(()=>{function u(y){return E=>{mt(t.current,y,E)}}function f(y){return()=>mt(t.current,y,Go)}function v(y){var E;o.current.has(y.key)||(o.current=ac(o.current,y.key));const Z=t.current.getState();return ct(t.current,y,Ge().early&&(E=Z.nextTree)!==null&&E!==void 0?E:Z.currentTree)}function _(y){const E=v(y);return Rn(E,y,t)}function V(y){return[_(y),u(y)]}function C(y){return[v(y),u(y)]}return{getRecoilValue:_,getRecoilValueLoadable:v,getRecoilState:V,getRecoilStateLoadable:C,getSetRecoilState:u,getResetRecoilState:f}},[o,t])}const cc={current:0};function lc(e){const t=me(),n=it(),o=se(()=>{var l;const u=t.current,f=u.getState(),v=Ge().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return{loadable:ct(u,e,v),key:e.key}},[t,e]),r=se(l=>{let u;return()=>{var f,v;const _=l();return(f=u)!==null&&f!==void 0&&f.loadable.is(_.loadable)&&((v=u)===null||v===void 0?void 0:v.key)===_.key?u:(u=_,_)}},[]),a=Ko(()=>r(o),[o,r]),s=se(l=>{const u=t.current;return Fe(u,e,l,n).release},[t,e,n]);return nc(s,a,a).loadable}function uc(e){const t=me(),n=se(()=>{var f;const v=t.current,_=v.getState(),V=Ge().early&&(f=_.nextTree)!==null&&f!==void 0?f:_.currentTree;return ct(v,e,V)},[t,e]),o=se(()=>n(),[n]),r=it(),a=se((f,v)=>{const _=t.current;return Fe(_,e,()=>{if(!z("recoil_suppress_rerender_in_callback"))return v();const C=n();u.current.is(C)||v(),u.current=C},r).release},[t,e,r,n]),s=oc();if(s==null)throw I("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const l=tc(s,o,a),u=tt(l);return xe(()=>{u.current=l}),l}function rn(e){const t=me(),n=it(),o=se(()=>{var u;const f=t.current,v=f.getState(),_=Ge().early&&(u=v.nextTree)!==null&&u!==void 0?u:v.currentTree;return ct(f,e,_)},[t,e]),r=se(()=>({loadable:o(),key:e.key}),[o,e.key]),a=se(u=>{const f=r();return u.loadable.is(f.loadable)&&u.key===f.key?u:f},[r]);xe(()=>{const u=Fe(t.current,e,f=>{l(a)},n);return l(a),u.release},[n,e,t,a]);const[s,l]=mn(r);return s.key!==e.key?r().loadable:s.loadable}function dc(e){const t=me(),[,n]=mn([]),o=it(),r=se(()=>{var l;const u=t.current,f=u.getState(),v=Ge().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return ct(u,e,v)},[t,e]),a=r(),s=tt(a);return xe(()=>{s.current=a}),xe(()=>{const l=t.current,u=l.getState(),f=Fe(l,e,_=>{var V;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const C=r();(V=s.current)!==null&&V!==void 0&&V.is(C)||n(C),s.current=C},o);if(u.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{s.current=null,n([])});else{var v;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const _=r();(v=s.current)!==null&&v!==void 0&&v.is(_)||n(_),s.current=_}return f.release},[o,r,e,t]),a}function yn(e){return z("recoil_memory_managament_2020")&&Sn(e),{TRANSITION_SUPPORT:rn,SYNC_EXTERNAL_STORE:ec()?lc:rn,MUTABLE_SOURCE:uc,LEGACY:dc}[Ge().mode](e)}function Ho(e){const t=me(),n=yn(e);return Rn(n,e,t)}function Ut(e){const t=me();return se(n=>{mt(t.current,e,n)},[t,e])}function fc(e){const t=me();return se(()=>{mt(t.current,e,Go)},[t,e])}function hc(e){return[Ho(e),Ut(e)]}function vc(e){return[yn(e),Ut(e)]}function pc(){const e=me();return(t,n={})=>{Qi(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>rc(e.current,new on(r),o))})}}function qo(e){return z("recoil_memory_managament_2020")&&Sn(e),rn(e)}function jo(e){const t=me(),n=qo(e);return Rn(n,e,t)}function _c(e){return[jo(e),Ut(e)]}var Sc={recoilComponentGetRecoilValueCount_FOR_TESTING:cc,useRecoilInterface:ic,useRecoilState:hc,useRecoilStateLoadable:vc,useRecoilValue:Ho,useRecoilValueLoadable:yn,useResetRecoilState:fc,useSetRecoilState:Ut,useSetUnvalidatedAtomValues:pc,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:qo,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:jo,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:_c};function mc(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n}var Rc=mc;function yc(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n}var gc=yc;function bc(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var Tc=bc;const{batchUpdates:wc}=Lt,{DEFAULT_VALUE:Ec,getNode:Zo,nodes:Ac}=ie,{useStoreRef:gn}=ge,{AbstractRecoilValue:Nc,setRecoilValueLoadable:Lc}=Se,{SUSPENSE_TIMEOUT_MS:Cc}=$e,{cloneSnapshot:Rt}=Mt,{useCallback:Dt,useEffect:Yo,useRef:On,useState:Vc}=j,{isSSR:Fn}=Ct;function kt(e){const t=gn();Yo(()=>t.current.subscribeToTransactions(e).release,[e,t])}function xn(e){const t=e.atomValues.toMap(),n=St(Rc(t,(o,r)=>{const s=Zo(r).persistence_UNSTABLE;return s!=null&&s.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return Tc(e.nonvalidatedAtoms.toMap(),n)}function $c(e){kt(Dt(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(n=t.getState().currentTree);const r=xn(o),a=xn(n),s=St(Ac,u=>{var f,v,_,V;return{persistence_UNSTABLE:{type:(f=(v=u.persistence_UNSTABLE)===null||v===void 0?void 0:v.type)!==null&&f!==void 0?f:"none",backButton:(_=(V=u.persistence_UNSTABLE)===null||V===void 0?void 0:V.backButton)!==null&&_!==void 0?_:!1}}}),l=gc(o.dirtyAtoms,u=>r.has(u)||a.has(u));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function Mc(e){kt(Dt(t=>{const n=Rt(t,"latest"),o=Rt(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function Ic(){const e=gn(),[t,n]=Vc(()=>Rt(e.current)),o=Wo(t),r=On(),a=On();if(kt(Dt(l=>n(Rt(l)),[])),Yo(()=>{const l=t.retain();if(r.current&&!Fn){var u;window.clearTimeout(r.current),r.current=null,(u=a.current)===null||u===void 0||u.call(a),a.current=null}return()=>{window.setTimeout(l,10)}},[t]),o!==t&&!Fn){if(r.current){var s;window.clearTimeout(r.current),r.current=null,(s=a.current)===null||s===void 0||s.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var l;r.current=null,(l=a.current)===null||l===void 0||l.call(a),a.current=null},Cc)}return t}function Xo(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;wc(()=>{const s=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const v of f){var l,u;((l=r.atomValues.get(v))===null||l===void 0?void 0:l.contents)!==((u=a.atomValues.get(v))===null||u===void 0?void 0:u.contents)&&Zo(v).shouldRestoreFromSnapshots&&s.add(v)}s.forEach(f=>{Lc(e,new Nc(f),a.atomValues.has(f)?q(a.atomValues.get(f)):Ec)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}function Uc(){const e=gn();return Dt(t=>Xo(e.current,t),[e])}var Jo={useRecoilSnapshot:Ic,gotoSnapshot:Xo,useGotoRecoilSnapshot:Uc,useRecoilTransactionObserver:Mc,useTransactionObservation_DEPRECATED:$c,useTransactionSubscription_DEPRECATED:kt};const{peekNodeInfo:Dc}=Te,{useStoreRef:kc}=ge;function Bc(){const e=kc();return({key:t})=>Dc(e.current,e.current.getState().currentTree,t)}var Pc=Bc;const{reactMode:Oc}=rt,{RecoilRoot:Fc,useStoreRef:xc}=ge,{useMemo:zc}=j;function Wc(){Oc().mode==="MUTABLE_SOURCE"&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const e=xc().current;return zc(()=>{function t({children:n}){return j.createElement(Fc,{store_INTERNAL:e},n)}return t},[e])}var Gc=Wc;const{loadableWithValue:Kc}=ot,{initializeNode:Hc}=Te,{DEFAULT_VALUE:qc,getNode:jc}=ie,{copyTreeState:Zc,getRecoilValueAsLoadable:Yc,invalidateDownstreams:Xc,writeLoadableToTreeState:Jc}=Se;function zn(e){return jc(e.key).nodeType==="atom"}class Qc{constructor(t,n){M(this,"_store",void 0),M(this,"_treeState",void 0),M(this,"_changes",void 0),M(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!zn(o))throw I("Reading selectors within atomicUpdate is not supported");const r=Yc(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:I(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),M(this,"set",(o,r)=>{if(!zn(o))throw I("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else Hc(this._store,o.key,"set"),this._changes.set(o.key,r)}),M(this,"reset",o=>{this.set(o,qc)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=Zc(this._treeState);for(const[n,o]of this._changes)Jc(t,n,Kc(o));return Xc(this._store,t),t}}function el(e){return t=>{e.replaceState(n=>{const o=new Qc(e,n);return t(o),o.newTreeState_INTERNAL()})}}var tl={atomicUpdater:el},nl=tl.atomicUpdater,Qo=Object.freeze({__proto__:null,atomicUpdater:nl});function ol(e,t){if(!e)throw new Error(t)}var rl=ol,Je=rl;const{atomicUpdater:al}=Qo,{batchUpdates:sl}=Lt,{DEFAULT_VALUE:il}=ie,{useStoreRef:cl}=ge,{refreshRecoilValue:ll,setRecoilValue:Wn}=Se,{cloneSnapshot:ul}=Mt,{gotoSnapshot:dl}=Jo,{useCallback:fl}=j;class er{}const hl=new er;function tr(e,t,n,o){let r=hl,a;if(sl(()=>{const l="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw I(l);const u=ho({...o??{},set:(v,_)=>Wn(e,v,_),reset:v=>Wn(e,v,il),refresh:v=>ll(e,v),gotoSnapshot:v=>dl(e,v),transact_UNSTABLE:v=>al(e)(v)},{snapshot:()=>{const v=ul(e);return a=v.retain(),v}}),f=t(u);if(typeof f!="function")throw I(l);r=f(...n)}),r instanceof er&&Je(!1),W(r))r=r.finally(()=>{var l;(l=a)===null||l===void 0||l()});else{var s;(s=a)===null||s===void 0||s()}return r}function vl(e,t){const n=cl();return fl((...o)=>tr(n.current,e,o),t!=null?[...t,n]:void 0)}var nr={recoilCallback:tr,useRecoilCallback:vl};const{useStoreRef:pl}=ge,{refreshRecoilValue:_l}=Se,{useCallback:Sl}=j;function ml(e){const t=pl();return Sl(()=>{const n=t.current;_l(n,e)},[e,t])}var Rl=ml;const{atomicUpdater:yl}=Qo,{useStoreRef:gl}=ge,{useMemo:bl}=j;function Tl(e,t){const n=gl();return bl(()=>(...o)=>{yl(n.current)(a=>{e(a)(...o)})},t!=null?[...t,n]:void 0)}var wl=Tl;class El{constructor(t){M(this,"value",void 0),this.value=t}}var Al={WrappedValue:El},Nl=Al.WrappedValue,or=Object.freeze({__proto__:null,WrappedValue:Nl});const{isFastRefreshEnabled:Ll}=rt;class Gn extends Error{}class Cl{constructor(t){var n,o,r;M(this,"_name",void 0),M(this,"_numLeafs",void 0),M(this,"_root",void 0),M(this,"_onHit",void 0),M(this,"_onSet",void 0),M(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,s,l,u;let f,v;for(const[Z,ne]of t){var _,V,C;const w=this._root;if((w==null?void 0:w.type)==="leaf")throw this.invalidCacheError();const B=f;if(f=B?B.branches.get(v):w,f=(_=f)!==null&&_!==void 0?_:{type:"branch",nodeKey:Z,parent:B,branches:new Map,branchKey:v},f.type!=="branch"||f.nodeKey!==Z)throw this.invalidCacheError();B==null||B.branches.set(v,f),o==null||(V=o.onNodeVisit)===null||V===void 0||V.call(o,f),v=this._mapNodeValue(ne),this._root=(C=this._root)!==null&&C!==void 0?C:f}const y=f?(a=f)===null||a===void 0?void 0:a.branches.get(v):this._root;if(y!=null&&(y.type!=="leaf"||y.branchKey!==v))throw this.invalidCacheError();const E={type:"leaf",value:n,parent:f,branchKey:v};(s=f)===null||s===void 0||s.branches.set(v,E),this._root=(l=this._root)!==null&&l!==void 0?l:E,this._numLeafs++,this._onSet(E),o==null||(u=o.onNodeVisit)===null||u===void 0||u.call(o,E)};try{r()}catch(a){if(a instanceof Gn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){const t=Ll()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw sn(t+(this._name!=null?` - ${this._name}`:"")),new Gn}}var Vl={TreeCache:Cl},$l=Vl.TreeCache,rr=Object.freeze({__proto__:null,TreeCache:$l});class Ml{constructor(t){var n;M(this,"_maxSize",void 0),M(this,"_size",void 0),M(this,"_head",void 0),M(this,"_tail",void 0),M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),s={key:t,right:a,left:null,value:n};a?a.left=s:this._tail=s,this._map.set(o,s),this._head=s,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=q(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var Il={LRUCache:Ml},Ul=Il.LRUCache,ar=Object.freeze({__proto__:null,LRUCache:Ul});const{LRUCache:Dl}=ar,{TreeCache:kl}=rr;function Bl({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new Dl({maxSize:t}),r=new kl({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const s=o.tail();o.set(a,!0),s&&r.size()>t&&r.delete(s.key)}});return r}var Kn=Bl;function _e(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw I("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(W(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>_e(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return _e(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,s]of e)r[typeof a=="string"?a:_e(a,t)]=s;return _e(r,t,n)}return e instanceof Set?_e(Array.from(e).sort((r,a)=>_e(r,t).localeCompare(_e(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?_e(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${_e(r,t)}:${_e(e[r],t,r)}`).join(",")}}`}function Pl(e,t={allowFunctions:!1}){return _e(e,t)}var Bt=Pl;const{TreeCache:Ol}=rr,ut={equality:"reference",eviction:"keep-all",maxSize:1/0};function Fl({equality:e=ut.equality,eviction:t=ut.eviction,maxSize:n=ut.maxSize}=ut,o){const r=xl(e);return zl(t,n,r,o)}function xl(e){switch(e){case"reference":return t=>t;case"value":return t=>Bt(t)}throw I(`Unrecognized equality policy ${e}`)}function zl(e,t,n,o){switch(e){case"keep-all":return new Ol({name:o,mapNodeValue:n});case"lru":return Kn({name:o,maxSize:q(t),mapNodeValue:n});case"most-recent":return Kn({name:o,maxSize:1,mapNodeValue:n})}throw I(`Unrecognized eviction policy ${e}`)}var Wl=Fl;function Gl(e){return()=>null}var Kl={startPerfBlock:Gl};const{isLoadable:Hl,loadableWithError:dt,loadableWithPromise:ql,loadableWithValue:jt}=ot,{WrappedValue:sr}=or,{getNodeLoadable:ft,peekNodeLoadable:jl,setNodeValue:Zl}=Te,{saveDepsToStore:Yl}=at,{DEFAULT_VALUE:Xl,getConfigDeletionHandler:Jl,getNode:Ql,registerNode:Hn}=ie,{isRecoilValue:eu}=Oe,{markRecoilValueModified:qn}=Se,{retainedByOptionWithDefault:tu}=$e,{recoilCallback:nu}=nr,{startPerfBlock:ou}=Kl;class ir{}const Ze=new ir,Ye=[],ht=new Map,ru=(()=>{let e=0;return()=>e++})();function cr(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,s=new Set,l=Wl(r??{equality:"reference",eviction:"keep-all"},n),u=tu(e.retainedBy_UNSTABLE),f=new Map;let v=0;function _(){return!z("recoil_memory_managament_2020")||v>0}function V(d){return d.getState().knownSelectors.add(n),v++,()=>{v--}}function C(){return Jl(n)!==void 0&&!_()}function y(d,p,S,$,b){de(p,$,b),E(d,S)}function E(d,p){ce(d,p)&&Q(d),ne(p,!0)}function Z(d,p){ce(d,p)&&(q(ee(d)).stateVersions.clear(),ne(p,!1))}function ne(d,p){const S=ht.get(d);if(S!=null){for(const $ of S)qn($,q(t));p&&ht.delete(d)}}function w(d,p){let S=ht.get(p);S==null&&ht.set(p,S=new Set),S.add(d)}function B(d,p,S,$,b,k){return p.then(D=>{if(!_())throw Q(d),Ze;const T=jt(D);return y(d,S,b,T,$),D}).catch(D=>{if(!_())throw Q(d),Ze;if(W(D))return J(d,D,S,$,b,k);const T=dt(D);throw y(d,S,b,T,$),D})}function J(d,p,S,$,b,k){return p.then(D=>{if(!_())throw Q(d),Ze;k.loadingDepKey!=null&&k.loadingDepPromise===p?S.atomValues.set(k.loadingDepKey,jt(D)):d.getState().knownSelectors.forEach(F=>{S.atomValues.delete(F)});const T=Y(d,S);if(T&&T.state!=="loading"){if((ce(d,b)||ee(d)==null)&&E(d,b),T.state==="hasValue")return T.contents;throw T.contents}if(!ce(d,b)){const F=Re(d,S);if(F!=null)return F.loadingLoadable.contents}const[K,te]=G(d,S,b);if(K.state!=="loading"&&y(d,S,b,K,te),K.state==="hasError")throw K.contents;return K.contents}).catch(D=>{if(D instanceof ir)throw Ze;if(!_())throw Q(d),Ze;const T=dt(D);throw y(d,S,b,T,$),D})}function x(d,p,S,$){var b,k,D,T;if(ce(d,$)||p.version===((b=d.getState())===null||b===void 0||(k=b.currentTree)===null||k===void 0?void 0:k.version)||p.version===((D=d.getState())===null||D===void 0||(T=D.nextTree)===null||T===void 0?void 0:T.version)){var K,te,F;Yl(n,S,d,(K=(te=d.getState())===null||te===void 0||(F=te.nextTree)===null||F===void 0?void 0:F.version)!==null&&K!==void 0?K:d.getState().currentTree.version)}for(const X of S)s.add(X)}function G(d,p,S){const $=ou(n);let b=!0,k=!0;const D=()=>{$(),k=!1};let T,K=!1,te;const F={loadingDepKey:null,loadingDepPromise:null},X=new Map;function ve({key:fe}){const le=ft(d,p,fe);switch(X.set(fe,le),b||(x(d,p,new Set(X.keys()),S),Z(d,S)),le.state){case"hasValue":return le.contents;case"hasError":throw le.contents;case"loading":throw F.loadingDepKey=fe,F.loadingDepPromise=le.contents,le.contents}throw I("Invalid Loadable state")}const Ae=fe=>(...le)=>{if(k)throw I("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&Je(!1),nu(d,fe,le,{node:t})};try{T=o({get:ve,getCallback:Ae}),T=eu(T)?ve(T):T,Hl(T)&&(T.state==="hasError"&&(K=!0),T=T.contents),W(T)?T=B(d,T,p,X,S,F).finally(D):D(),T=T instanceof sr?T.value:T}catch(fe){T=fe,W(T)?T=J(d,T,p,X,S,F).finally(D):(K=!0,D())}return K?te=dt(T):W(T)?te=ql(T):te=jt(T),b=!1,Me(d,S,X),x(d,p,new Set(X.keys()),S),[te,X]}function Y(d,p){let S=p.atomValues.get(n);if(S!=null)return S;const $=new Set;try{S=l.get(k=>(typeof k!="string"&&Je(!1),ft(d,p,k).contents),{onNodeVisit:k=>{k.type==="branch"&&k.nodeKey!==n&&$.add(k.nodeKey)}})}catch(k){throw I(`Problem with cache lookup for selector "${n}": ${k.message}`)}if(S){var b;p.atomValues.set(n,S),x(d,p,$,(b=ee(d))===null||b===void 0?void 0:b.executionID)}return S}function re(d,p){const S=Y(d,p);if(S!=null)return Q(d),S;const $=Re(d,p);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&w(d,$.executionID),$.loadingLoadable}const k=ru(),[D,T]=G(d,p,k);return D.state==="loading"?(ue(d,k,D,T,p),w(d,k)):(Q(d),de(p,D,T)),D}function Re(d,p){const S=Vo([f.has(d)?[q(f.get(d))]:[],wt(fn(f,([b])=>b!==d),([,b])=>b)]);function $(b){for(const[k,D]of b)if(!ft(d,p,k).is(D))return!0;return!1}for(const b of S){if(b.stateVersions.get(p.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(p.version,!0),b;b.stateVersions.set(p.version,!1)}}function ee(d){return f.get(d)}function ue(d,p,S,$,b){f.set(d,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:p,loadingLoadable:S,stateVersions:new Map([[b.version,!0]])})}function Me(d,p,S){if(ce(d,p)){const $=ee(d);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=S)}}function Q(d){f.delete(d)}function ce(d,p){var S;return p===((S=ee(d))===null||S===void 0?void 0:S.executionID)}function Ee(d){return Array.from(d.entries()).map(([p,S])=>[p,S.contents])}function de(d,p,S){d.atomValues.set(n,p);try{l.set(Ee(S),p)}catch($){throw I(`Problem with setting cache for selector "${n}": ${$.message}`)}}function ye(d){if(Ye.includes(n)){const p=`Recoil selector has circular dependencies: ${Ye.slice(Ye.indexOf(n)).join("  ")}`;return dt(I(p))}Ye.push(n);try{return d()}finally{Ye.pop()}}function Ie(d,p){const S=p.atomValues.get(n);return S??l.get($=>{var b;return typeof $!="string"&&Je(!1),(b=jl(d,p,$))===null||b===void 0?void 0:b.contents})}function Ue(d,p){return ye(()=>re(d,p))}function P(d){d.atomValues.delete(n)}function O(d,p){t==null&&Je(!1);for(const $ of s){var S;const b=Ql($);(S=b.clearCache)===null||S===void 0||S.call(b,d,p)}s.clear(),P(p),l.clear(),qn(d,t)}return a!=null?t=Hn({key:n,nodeType:"selector",peek:Ie,get:Ue,set:(p,S,$)=>{let b=!1;const k=new Map;function D({key:F}){if(b)throw I("Recoil: Async selector sets are not currently supported.");const X=ft(p,S,F);if(X.state==="hasValue")return X.contents;if(X.state==="loading"){const ve=`Getting value of asynchronous atom or selector "${F}" in a pending state while setting selector "${n}" is not yet supported.`;throw I(ve)}else throw X.contents}function T(F,X){if(b)throw I("Recoil: Async selector sets are not currently supported.");const ve=typeof X=="function"?X(D(F)):X;Zl(p,S,F.key,ve).forEach((fe,le)=>k.set(le,fe))}function K(F){T(F,Xl)}const te=a({set:T,get:D,reset:K},$);if(te!==void 0)throw W(te)?I("Recoil: Async selector sets are not currently supported."):I("Recoil: selector set should be a void function.");return b=!0,k},init:V,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:C,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u}):t=Hn({key:n,nodeType:"selector",peek:Ie,get:Ue,init:V,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:C,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}cr.value=e=>new sr(e);var ze=cr;const{isLoadable:au,loadableWithError:Zt,loadableWithPromise:Yt,loadableWithValue:ke}=ot,{WrappedValue:lr}=or,{peekNodeInfo:su}=Te,{DEFAULT_VALUE:Ne,DefaultValue:be,getConfigDeletionHandler:ur,registerNode:iu,setConfigDeletionHandler:cu}=ie,{isRecoilValue:lu}=Oe,{getRecoilValueAsLoadable:uu,markRecoilValueModified:du,setRecoilValue:jn,setRecoilValueLoadable:fu}=Se,{retainedByOptionWithDefault:hu}=$e,Xe=e=>e instanceof lr?e.value:e;function vu(e){const{key:t,persistence_UNSTABLE:n}=e,o=hu(e.retainedBy_UNSTABLE);let r=0;function a(w){return Yt(w.then(B=>(s=ke(B),B)).catch(B=>{throw s=Zt(B),B}))}let s=W(e.default)?a(e.default):au(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:ke(Xe(e.default));s.contents;let l;const u=new Map;function f(w){return w}function v(w,B){const J=B.then(x=>{var G,Y;return((Y=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||Y===void 0?void 0:Y.contents)===J&&jn(w,ne,x),x}).catch(x=>{var G,Y;throw((Y=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||Y===void 0?void 0:Y.contents)===J&&fu(w,ne,Zt(x)),x});return J}function _(w,B,J){var x;r++;const G=()=>{var ee;r--,(ee=u.get(w))===null||ee===void 0||ee.forEach(ue=>ue()),u.delete(w)};if(w.getState().knownAtoms.add(t),s.state==="loading"){const ee=()=>{var ue;((ue=w.getState().nextTree)!==null&&ue!==void 0?ue:w.getState().currentTree).atomValues.has(t)||du(w,ne)};s.contents.finally(ee)}const Y=(x=e.effects)!==null&&x!==void 0?x:e.effects_UNSTABLE;if(Y!=null){let ee=function(P){if(ce&&P.key===t){const O=Q;return O instanceof be?V(w,B):W(O)?Yt(O.then(d=>d instanceof be?s.toPromise():d)):ke(O)}return uu(w,P)},ue=function(P){return ee(P).toPromise()},Me=function(P){var O;const d=su(w,(O=w.getState().nextTree)!==null&&O!==void 0?O:w.getState().currentTree,P.key);return ce&&P.key===t&&!(Q instanceof be)?{...d,isSet:!0,loadable:ee(P)}:d},Q=Ne,ce=!0,Ee=!1,de=null;const ye=P=>O=>{if(ce){const d=ee(ne),p=d.state==="hasValue"?d.contents:Ne;Q=typeof O=="function"?O(p):O,W(Q)&&(Q=Q.then(S=>(de={effect:P,value:S},S)))}else{if(W(O))throw I("Setting atoms to async values is not implemented.");typeof O!="function"&&(de={effect:P,value:Xe(O)}),jn(w,ne,typeof O=="function"?d=>{const p=Xe(O(d));return de={effect:P,value:p},p}:Xe(O))}},Ie=P=>()=>ye(P)(Ne),Ue=P=>O=>{var d;const{release:p}=w.subscribeToTransactions(S=>{var $;let{currentTree:b,previousTree:k}=S.getState();k||(k=b);const D=($=b.atomValues.get(t))!==null&&$!==void 0?$:s;if(D.state==="hasValue"){var T,K,te,F;const X=D.contents,ve=(T=k.atomValues.get(t))!==null&&T!==void 0?T:s,Ae=ve.state==="hasValue"?ve.contents:Ne;((K=de)===null||K===void 0?void 0:K.effect)!==P||((te=de)===null||te===void 0?void 0:te.value)!==X?O(X,Ae,!b.atomValues.has(t)):((F=de)===null||F===void 0?void 0:F.effect)===P&&(de=null)}},t);u.set(w,[...(d=u.get(w))!==null&&d!==void 0?d:[],p])};for(const P of Y)try{const O=P({node:ne,storeID:w.storeID,parentStoreID_UNSTABLE:w.parentStoreID,trigger:J,setSelf:ye(P),resetSelf:Ie(P),onSet:Ue(P),getPromise:ue,getLoadable:ee,getInfo_UNSTABLE:Me});if(O!=null){var re;u.set(w,[...(re=u.get(w))!==null&&re!==void 0?re:[],O])}}catch(O){Q=O,Ee=!0}if(ce=!1,!(Q instanceof be)){var Re;const P=Ee?Zt(Q):W(Q)?Yt(v(w,Q)):ke(Xe(Q));P.contents,B.atomValues.set(t,P),(Re=w.getState().nextTree)===null||Re===void 0||Re.atomValues.set(t,P)}}return G}function V(w,B){var J,x;return(J=(x=B.atomValues.get(t))!==null&&x!==void 0?x:l)!==null&&J!==void 0?J:s}function C(w,B){if(B.atomValues.has(t))return q(B.atomValues.get(t));if(B.nonvalidatedAtoms.has(t)){if(l!=null)return l;if(n==null)return s;const J=B.nonvalidatedAtoms.get(t),x=n.validator(J,Ne);return l=x instanceof be?s:ke(x),l}else return s}function y(){l=void 0}function E(w,B,J){if(B.atomValues.has(t)){const x=q(B.atomValues.get(t));if(x.state==="hasValue"&&J===x.contents)return new Map}else if(!B.nonvalidatedAtoms.has(t)&&J instanceof be)return new Map;return l=void 0,new Map().set(t,ke(J))}function Z(){return ur(t)!==void 0&&r<=0}const ne=iu({key:t,nodeType:"atom",peek:V,get:C,set:E,init:_,invalidate:y,shouldDeleteConfigOnRelease:Z,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return ne}function bn(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return lu(n)?pu({...t,default:n}):vu({...t,default:n})}function pu(e){const t=bn({...e,default:Ne,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof be?o:q(e.persistence_UNSTABLE).validator(o,Ne)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=ze({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof be?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return cu(n.key,ur(e.key)),n}bn.value=e=>new lr(e);var dr=bn;class _u{constructor(t){var n;M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var Su={MapCache:_u},mu=Su.MapCache,Ru=Object.freeze({__proto__:null,MapCache:mu});const{LRUCache:Zn}=ar,{MapCache:yu}=Ru,vt={equality:"reference",eviction:"none",maxSize:1/0};function gu({equality:e=vt.equality,eviction:t=vt.eviction,maxSize:n=vt.maxSize}=vt){const o=bu(e);return Tu(t,n,o)}function bu(e){switch(e){case"reference":return t=>t;case"value":return t=>Bt(t)}throw I(`Unrecognized equality policy ${e}`)}function Tu(e,t,n){switch(e){case"keep-all":return new yu({mapKey:n});case"lru":return new Zn({mapKey:n,maxSize:q(t)});case"most-recent":return new Zn({mapKey:n,maxSize:1})}throw I(`Unrecognized eviction policy ${e}`)}var fr=gu;const{setConfigDeletionHandler:wu}=ie;function Eu(e){var t,n;const o=fr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a,s;const l=o.get(r);if(l!=null)return l;const{cachePolicyForParams_UNSTABLE:u,...f}=e,v="default"in e?e.default:new Promise(()=>{}),_=dr({...f,key:`${e.key}__${(a=Bt(r))!==null&&a!==void 0?a:"void"}`,default:typeof v=="function"?v(r):v,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,effects:typeof e.effects=="function"?e.effects(r):typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(r):(s=e.effects)!==null&&s!==void 0?s:e.effects_UNSTABLE});return o.set(r,_),wu(_.key,()=>{o.delete(r)}),_}}var Au=Eu;const{setConfigDeletionHandler:Nu}=ie;let Lu=0;function Cu(e){var t,n;const o=fr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let s;try{s=o.get(r)}catch(V){throw I(`Problem with cache lookup for selector ${e.key}: ${V.message}`)}if(s!=null)return s;const l=`${e.key}__selectorFamily/${(a=Bt(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${Lu++}`,u=V=>e.get(r)(V),f=e.cachePolicy_UNSTABLE,v=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let _;if(e.set!=null){const V=e.set;_=ze({key:l,get:u,set:(y,E)=>V(r)(y,E),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v})}else _=ze({key:l,get:u,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v});return o.set(r,_),Nu(_.key,()=>{o.delete(r)}),_}}var we=Cu;const Vu=we({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function $u(e){return Vu(e)}var Mu=$u;const Iu=we({key:"__error",get:e=>()=>{throw I(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Uu(e){return Iu(e)}var Du=Uu;function ku(e){return e}var Bu=ku;const{loadableWithError:hr,loadableWithPromise:vr,loadableWithValue:pr}=ot;function Pt(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(s){o[r]=s}return[n,o]}function Pu(e){return e!=null&&!W(e)}function Ot(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function an(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function Be(e,t,n){const o=n.map((r,a)=>r==null?pr(t[a]):W(r)?vr(r):hr(r));return an(e,o)}function Ou(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}const Fu=we({key:"__waitForNone",get:e=>({get:t})=>{const n=Ot(e),[o,r]=Pt(t,n);return Be(e,o,r)},dangerouslyAllowMutability:!0}),xu=we({key:"__waitForAny",get:e=>({get:t})=>{const n=Ot(e),[o,r]=Pt(t,n);return r.some(a=>!W(a))?Be(e,o,r):new Promise(a=>{for(const[s,l]of r.entries())W(l)&&l.then(u=>{o[s]=u,r[s]=void 0,a(Be(e,o,r))}).catch(u=>{r[s]=u,a(Be(e,o,r))})})},dangerouslyAllowMutability:!0}),zu=we({key:"__waitForAll",get:e=>({get:t})=>{const n=Ot(e),[o,r]=Pt(t,n);if(r.every(s=>s==null))return an(e,o);const a=r.find(Pu);if(a!=null)throw a;return Promise.all(r).then(s=>an(e,Ou(o,s)))},dangerouslyAllowMutability:!0}),Wu=we({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Ot(e),[o,r]=Pt(t,n);return r.every(a=>!W(a))?Be(e,o,r):Promise.all(r.map((a,s)=>W(a)?a.then(l=>{o[s]=l,r[s]=void 0}).catch(l=>{o[s]=void 0,r[s]=l}):null)).then(()=>Be(e,o,r))},dangerouslyAllowMutability:!0}),Gu=we({key:"__noWait",get:e=>({get:t})=>{try{return ze.value(pr(t(e)))}catch(n){return ze.value(W(n)?vr(n):hr(n))}},dangerouslyAllowMutability:!0});var Ku={waitForNone:Fu,waitForAny:xu,waitForAll:zu,waitForAllSettled:Wu,noWait:Gu};const{RecoilLoadable:Hu}=ot,{DefaultValue:qu}=ie,{RecoilRoot:ju,useRecoilStoreID:Zu}=ge,{isRecoilValue:Yu}=Oe,{retentionZone:Xu}=At,{freshSnapshot:Ju}=Mt,{useRecoilState:Qu,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:ed,useRecoilStateLoadable:td,useRecoilValue:nd,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:od,useRecoilValueLoadable:rd,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ad,useResetRecoilState:sd,useSetRecoilState:id}=Sc,{useGotoRecoilSnapshot:cd,useRecoilSnapshot:ld,useRecoilTransactionObserver:ud}=Jo,{useRecoilCallback:dd}=nr,{noWait:fd,waitForAll:hd,waitForAllSettled:vd,waitForAny:pd,waitForNone:_d}=Ku;var Tn={DefaultValue:qu,isRecoilValue:Yu,RecoilLoadable:Hu,RecoilEnv:We,RecoilRoot:ju,useRecoilStoreID:Zu,useRecoilBridgeAcrossReactRoots_UNSTABLE:Gc,atom:dr,selector:ze,atomFamily:Au,selectorFamily:we,constSelector:Mu,errorSelector:Du,readOnlySelector:Bu,noWait:fd,waitForNone:_d,waitForAny:pd,waitForAll:hd,waitForAllSettled:vd,useRecoilValue:nd,useRecoilValueLoadable:rd,useRecoilState:Qu,useRecoilStateLoadable:td,useSetRecoilState:id,useResetRecoilState:sd,useGetRecoilValueInfo_UNSTABLE:Pc,useRecoilRefresher_UNSTABLE:Rl,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ad,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:od,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:ed,useRecoilCallback:dd,useRecoilTransaction_UNSTABLE:wl,useGotoRecoilSnapshot:cd,useRecoilSnapshot:ld,useRecoilTransactionObserver_UNSTABLE:ud,snapshot_UNSTABLE:Ju,useRetain:Sn,retentionZone:Xu},Rd=Tn.RecoilRoot,yd=Tn.atom,gd=Tn.useRecoilState;export{yd as R,gd as a,Rd as b};
